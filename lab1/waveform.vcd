$version Generated by VerilatedVcd $end
$date Tue Aug 15 21:51:28 2023
 $end
$timescale   1ps $end

 $scope module TOP $end
  $var wire  1 ` clk $end
  $scope module cpu $end
   $var wire  2 8 aluOp [1:0] $end
   $var wire  1 4 aluSrc $end
   $var wire  4 9 alu_control_out [3:0] $end
   $var wire 32 . alu_out [31:0] $end
   $var wire  1 0 branch $end
   $var wire  1 ` clk $end
   $var wire 32 & currentpc [31:0] $end
   $var wire 32 a data_mux_out [31:0] $end
   $var wire 32 b data_out [31:0] $end
   $var wire 32 * immediate [31:0] $end
   $var wire 32 ' ins [31:0] $end
   $var wire  1 1 memRead $end
   $var wire  1 2 memToReg $end
   $var wire  1 3 memWrite $end
   $var wire 32 / nextpc [31:0] $end
   $var wire 32 % pc_add_out [31:0] $end
   $var wire  1 7 pc_mux_sig $end
   $var wire 32 ( readData1 [31:0] $end
   $var wire 32 ) readData2 [31:0] $end
   $var wire  1 5 regWrite $end
   $var wire 32 - reg_mux_out [31:0] $end
   $var wire 32 , shift_add_out [31:0] $end
   $var wire 32 + shifted [31:0] $end
   $var wire  1 6 zero $end
   $scope module a1 $end
    $var wire 32 ( a [31:0] $end
    $var wire 32 - b [31:0] $end
    $var wire  4 9 control [3:0] $end
    $var wire 32 . y [31:0] $end
    $var wire  1 6 zero $end
   $upscope $end
   $scope module acontrol $end
    $var wire  2 8 aluOp [1:0] $end
    $var wire  4 9 control [3:0] $end
    $var wire  4 _ ins [3:0] $end
   $upscope $end
   $scope module data_mux $end
    $var wire 32 . mux0 [31:0] $end
    $var wire 32 b mux1 [31:0] $end
    $var wire  1 2 muxSignal $end
    $var wire 32 a selected [31:0] $end
   $upscope $end
   $scope module dmemory $end
    $var wire 32 . address [31:0] $end
    $var wire  1 1 memRead $end
    $var wire  1 3 memWrite $end
    $var wire 32 b readData [31:0] $end
    $var wire 32 ) writeData [31:0] $end
   $upscope $end
   $scope module imm $end
    $var wire 32 * immediate [31:0] $end
    $var wire 32 ' instruction [31:0] $end
   $upscope $end
   $scope module insmemory $end
    $var wire 32 & address [31:0] $end
    $var wire 32 ' instruction [31:0] $end
    $var wire  7 # n [6:0] $end
   $upscope $end
   $scope module mcontrol $end
    $var wire  2 8 aluOp [1:0] $end
    $var wire  1 4 aluSrc $end
    $var wire  1 0 branch $end
    $var wire  8 ; control [7:0] $end
    $var wire  7 : ins [6:0] $end
    $var wire  1 1 memRead $end
    $var wire  1 2 memToReg $end
    $var wire  1 3 memWrite $end
    $var wire  1 5 regWrite $end
   $upscope $end
   $scope module pc_add $end
    $var wire 32 c addNum [31:0] $end
    $var wire 32 % nextpc [31:0] $end
    $var wire 32 & pc [31:0] $end
   $upscope $end
   $scope module pc_mux $end
    $var wire 32 % mux0 [31:0] $end
    $var wire 32 , mux1 [31:0] $end
    $var wire  1 7 muxSignal $end
    $var wire 32 / selected [31:0] $end
   $upscope $end
   $scope module program_counter $end
    $var wire  1 ` clk $end
    $var wire 32 & currentpc [31:0] $end
    $var wire 32 / nextpc [31:0] $end
   $upscope $end
   $scope module r1 $end
    $var wire  1 ` clk $end
    $var wire 32 ( data1 [31:0] $end
    $var wire 32 ) data2 [31:0] $end
    $var wire 32 $ i [31:0] $end
    $var wire  5 < read1 [4:0] $end
    $var wire  5 = read2 [4:0] $end
    $var wire  1 5 regWrite $end
    $var wire 32 ? registers(0) [31:0] $end
    $var wire 32 @ registers(1) [31:0] $end
    $var wire 32 I registers(10) [31:0] $end
    $var wire 32 J registers(11) [31:0] $end
    $var wire 32 K registers(12) [31:0] $end
    $var wire 32 L registers(13) [31:0] $end
    $var wire 32 M registers(14) [31:0] $end
    $var wire 32 N registers(15) [31:0] $end
    $var wire 32 O registers(16) [31:0] $end
    $var wire 32 P registers(17) [31:0] $end
    $var wire 32 Q registers(18) [31:0] $end
    $var wire 32 R registers(19) [31:0] $end
    $var wire 32 A registers(2) [31:0] $end
    $var wire 32 S registers(20) [31:0] $end
    $var wire 32 T registers(21) [31:0] $end
    $var wire 32 U registers(22) [31:0] $end
    $var wire 32 V registers(23) [31:0] $end
    $var wire 32 W registers(24) [31:0] $end
    $var wire 32 X registers(25) [31:0] $end
    $var wire 32 Y registers(26) [31:0] $end
    $var wire 32 Z registers(27) [31:0] $end
    $var wire 32 [ registers(28) [31:0] $end
    $var wire 32 \ registers(29) [31:0] $end
    $var wire 32 B registers(3) [31:0] $end
    $var wire 32 ] registers(30) [31:0] $end
    $var wire 32 ^ registers(31) [31:0] $end
    $var wire 32 C registers(4) [31:0] $end
    $var wire 32 D registers(5) [31:0] $end
    $var wire 32 E registers(6) [31:0] $end
    $var wire 32 F registers(7) [31:0] $end
    $var wire 32 G registers(8) [31:0] $end
    $var wire 32 H registers(9) [31:0] $end
    $var wire  5 > write [4:0] $end
    $var wire 32 a writeData [31:0] $end
   $upscope $end
   $scope module reg_mux $end
    $var wire 32 ) mux0 [31:0] $end
    $var wire 32 * mux1 [31:0] $end
    $var wire  1 4 muxSignal $end
    $var wire 32 - selected [31:0] $end
   $upscope $end
   $scope module sh $end
    $var wire 32 + shifted [31:0] $end
    $var wire 32 * unshift [31:0] $end
   $upscope $end
   $scope module shift_add $end
    $var wire 32 + addNum [31:0] $end
    $var wire 32 , nextpc [31:0] $end
    $var wire 32 & pc [31:0] $end
   $upscope $end
  $upscope $end
 $upscope $end
$enddefinitions $end


#0
b0000111 #
b00000000000000000000000000100000 $
b00000000000000000000000000000100 %
b00000000000000000000000000000000 &
b00001010001100000000010000010011 '
b00000000000000000000000000000000 (
b00000000000000000000000000000000 )
b00000000000000000000000010100011 *
b00000000000000000000000101000110 +
b00000000000000000000000101000110 ,
b00000000000000000000000000000000 -
b00000000000000000000000000000000 .
b00000000000000000000000101000110 /
10
01
12
03
04
05
16
17
b11 8
b0000 9
b0010011 :
b10100011 ;
b00000 <
b00011 =
b01000 >
b00000000000000000000000000000000 ?
b00000000000000000000000000000000 @
b00000000000000000000000000000000 A
b00000000000000000000000000000000 B
b00000000000000000000000000000000 C
b00000000000000000000000000000000 D
b00000000000000000000000000000000 E
b00000000000000000000000000000000 F
b00000000000000000000000000000000 G
b00000000000000000000000000000000 H
b00000000000000000000000000000000 I
b00000000000000000000000000000000 J
b00000000000000000000000000000000 K
b00000000000000000000000000000000 L
b00000000000000000000000000000000 M
b00000000000000000000000000000000 N
b00000000000000000000000000000000 O
b00000000000000000000000000000000 P
b00000000000000000000000000000000 Q
b00000000000000000000000000000000 R
b00000000000000000000000000000000 S
b00000000000000000000000000000000 T
b00000000000000000000000000000000 U
b00000000000000000000000000000000 V
b00000000000000000000000000000000 W
b00000000000000000000000000000000 X
b00000000000000000000000000000000 Y
b00000000000000000000000000000000 Z
b00000000000000000000000000000000 [
b00000000000000000000000000000000 \
b00000000000000000000000000000000 ]
b00000000000000000000000000000000 ^
b0000 _
1`
b00000000000000000000000000000000 a
b00000000000000000000000000000000 b
b00000000000000000000000000000100 c
#1
0`
#2
b00000000000000000000000101001010 %
b00000000000000000000000101000110 &
b00000000000000000000000000000000 '
b00000000000000000000000000000000 *
b00000000000000000000000000000000 +
b00000000000000000000000101001010 /
00
02
07
b00 8
b0010 9
b0000000 :
b00000000 ;
b00000 =
b00000 >
1`
#3
0`
#4
b00000000000000000000000101001110 %
b00000000000000000000000101001010 &
b00000000000000000000000101001010 ,
b00000000000000000000000101001110 /
1`
#5
0`
#6
b00000000000000000000000101010010 %
b00000000000000000000000101001110 &
b00000000000000000000000101001110 ,
b00000000000000000000000101010010 /
1`
#7
0`
#8
b00000000000000000000000101010110 %
b00000000000000000000000101010010 &
b00000000000000000000000101010010 ,
b00000000000000000000000101010110 /
1`
#9
0`
#10
b00000000000000000000000101011010 %
b00000000000000000000000101010110 &
b00000000000000000000000101010110 ,
b00000000000000000000000101011010 /
1`
#11
0`
#12
b00000000000000000000000101011110 %
b00000000000000000000000101011010 &
b00000000000000000000000101011010 ,
b00000000000000000000000101011110 /
1`
#13
0`
#14
b00000000000000000000000101100010 %
b00000000000000000000000101011110 &
b00000000000000000000000101011110 ,
b00000000000000000000000101100010 /
1`
#15
0`
#16
b00000000000000000000000101100110 %
b00000000000000000000000101100010 &
b00000000000000000000000101100010 ,
b00000000000000000000000101100110 /
1`
#17
0`
#18
b00000000000000000000000101101010 %
b00000000000000000000000101100110 &
b00000000000000000000000101100110 ,
b00000000000000000000000101101010 /
1`
#19
0`
#20
b00000000000000000000000101101110 %
b00000000000000000000000101101010 &
b00000000000000000000000101101010 ,
b00000000000000000000000101101110 /
1`
#21
0`
#22
b00000000000000000000000101110010 %
b00000000000000000000000101101110 &
b00000000000000000000000101101110 ,
b00000000000000000000000101110010 /
1`
#23
0`
#24
b00000000000000000000000101110110 %
b00000000000000000000000101110010 &
b00000000000000000000000101110010 ,
b00000000000000000000000101110110 /
1`
#25
0`
#26
b00000000000000000000000101111010 %
b00000000000000000000000101110110 &
b00000000000000000000000101110110 ,
b00000000000000000000000101111010 /
1`
#27
0`
#28
b00000000000000000000000101111110 %
b00000000000000000000000101111010 &
b00000000000000000000000101111010 ,
b00000000000000000000000101111110 /
1`
#29
0`
#30
b00000000000000000000000110000010 %
b00000000000000000000000101111110 &
b00000000000000000000101000110000 '
b00000000000000000000000101111110 ,
b00000000000000000000000110000010 /
b0110000 :
b10100 >
1`
#31
0`
#32
b00000000000000000000000110000110 %
b00000000000000000000000110000010 &
b00000100000100111111111111000001 '
b00000000000000000000000110000010 ,
b00000000000000000000000110000110 /
b1000001 :
b00111 <
b00001 =
b11111 >
b0111 _
1`
#33
0`
#34
b00000000000000000000000110001010 %
b00000000000000000000000110000110 &
b00000001000100110000000010000001 '
b00000000000000000000000110000110 ,
b00000000000000000000000110001010 /
b0000001 :
b00110 <
b10001 =
b00001 >
b0000 _
1`
#35
0`
#36
b00000000000000000000000110001110 %
b00000000000000000000000110001010 &
b00100000001000110000000000000000 '
b00000000000000000000000110001010 ,
b00000000000000000000000110001110 /
b0000000 :
b00010 =
b00000 >
1`
#37
0`
#38
b00000000000000000000000110010010 %
b00000000000000000000000110001110 &
b00000100001100110000000000000000 '
b00000000000000000000000110001110 ,
b00000000000000000000000110010010 /
b00011 =
1`
#39
0`
#40
b00000000000000000000000110010110 %
b00000000000000000000000110010010 &
b00000010100100110000000001110010 '
b00000000000000000000000110010010 ,
b00000000000000000000000110010110 /
b1110010 :
b01001 =
1`
#41
0`
#42
b00000000000000000000000110011010 %
b00000000000000000000000110010110 &
b10100011000100110000000000000011 '
b11111111111111111111101000110001 *
b11111111111111111111010001100010 +
b11111111111111111111010111111000 ,
b11111111111111111111010111111000 /
10
11
12
13
17
b0000011 :
b11110000 ;
b10001 =
1`
#43
0`
#44
b11111111111111111111010111111100 %
b11111111111111111111010111111000 &
b00000000000000000000000000000000 '
b00000000000000000000000000000000 *
b00000000000000000000000000000000 +
b11111111111111111111010111111100 /
00
01
02
03
07
b0000000 :
b00000000 ;
b00000 <
b00000 =
1`
#45
0`
#46
b11111111111111111111011000000000 %
b11111111111111111111010111111100 &
b11111111111111111111010111111100 ,
b11111111111111111111011000000000 /
1`
#47
0`
